<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="">
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  <title>Document</title>
  <link href="../docs.css" type="text/css" rel="stylesheet"></link>
  <script type="text/javascript" src="../../Scripts/yi.core.js"></script>
  <script type="text/javascript" src="../../Scripts/yi.diagnosis.js"></script>
  <script type="text/javascript" src="../../Scripts/yi.assert.helper.js"></script>
 </head>
 <body>
 <h1>yi.Whenable</h1>
 <fieldset class='summary class x-able'>
	<legend>描述</legend>
	带when函数与thenWhen函数的Thenable
 </fieldset>
 <fieldset class='member function'>
	<legend><h2>yi.Whenable.when</h2></legend>
	<ul><li><h3>Instructions</h3>
	<table class='descriptor'>
		<thead>
			<tr><th colspan="3" class='name'>Description</th></tr>
			<tr><td colspan ="3" class='description'>设定一个异步操作或等待对象(也是异步的resolve)</td></tr>
			<tr><th colspan="3" class='name'>Parameters</th></tr>
			<tr><th class='name'>Name</th><th class='type'>Type</th><th class='description'>Description</th></tr>
			
		</thead>
		<tbody class='parameters'>
			<tr><td class='name'>obj</td><td class='type'>function/Thenable/*</td><td  class='description'>
			<ol>
				<li>当该参数是一个函数时，会异步调用该函数.该函数的this与第一个参数，是本Whenable。第二个参数是when函数的第二个参数。如果该函数执行失败，本Whenable会被拒绝掉，reason是函数抛出的Error</li>
				<li>当该参数是一个Thenable时，会生成该Thenable的包装。里面的Thenable resolve或reject或notify事件会传递给本Whenable</li>
				<li>当该参数是其他类型的值时，会异步的resolve掉本Whenable.</li>
			<ol></td></td>
			
		</tbody>
		<tfoot>
			<tr>
				<th colspan="3"></th>
			</tr>
		</tfoot>
	</table></li>
	<li><script subtype='test'>
$assert.scope(function($assert,log){
var fn = function(args,d){
	$assert.Equal(dfd,this);//$assert.line
	$assert.Equal(dfd,d);//$assert.line
	$assert.Equal("s",args);//$assert.line
	log("execute fn:" + args);
	d.resolve("hello");
	$assert.t=($assert.t||0)+1;//$assert.line
};
log("when 一个函数");
var dfd = new yi.Whenable();
dfd.name = "dfd";
dfd.when(fn,"s").then(function(value){
	$assert.Equal("hello",value);//$assert.line
	log("dfd is resolved with:" + value);
	$assert.t1=($assert.t1||0)+1;//$assert.line
});
//$assert.wait(5).For(function(){return $assert.t1&& $assert.t}).done(function(){
	$assert.Equal(1,$assert.t);//$assert.line
	$assert.Equal(1,$assert.t1);//$assert.line
//});

log("when Thenable");
 
var inner = new yi.Thenable();
inner.name = "inner";
var dfd2 = new yi.Whenable();
dfd2.name = "dfd2";
dfd2.when(inner).then(function(value){
	log("dfd2 was done with value:" + value);
	$assert.Equal(dfd2,this);//$assert.line
	$assert.Equal("inn",value);//$assert.line
	$assert.tx=($assert.tx||0)+1;//$assert.line
});

inner.resolve("inn");
//$assert.wait(5).For(function(){return $assert.t1&& $assert.t}).done(function(){
	$assert.Equal(1,$assert.tx);//$assert.line
//});

log("when function throw err");
var when = function(){throw "my error";}
var dfd3 = new yi.Whenable(when).fail(function(reason){
	log("dfd会被拒绝掉");
	$assert.whenError =reason;
});
$assert("my error",$assert.whenError);
});
	</script></li>
	</ul>
 </fieldset>
 
 <fieldset class='member function'>
	<legend><h2>yi.Thenable.thenWhen</h2></legend>
	<ul><li><h3>Instructions</h3>
	<table class='descriptor'>
		<thead>
			<tr><th colspan="3" class='name'>Description</th></tr>
			<tr><td colspan ="3" class='description'>让一系列的Thenable可以做链式操作</td></tr>
			<tr><th colspan="3" class='name'>Parameters</th></tr>
			<tr><th class='name'>Name</th><th class='type'>Type</th><th class='description'>Description</th></tr>
			
		</thead>
		<tbody class='parameters'>
			<tr><td class='name'>obj</td><td class='type'>function/Thenable/*</td><td  class='description'>
			参数含义如同then,但并不是立即执行，而是等待当前操作完成后，把参数当作when的第一个参数来执行。这个函数特别适合串行的一系列异步操作</td></td>
			
		</tbody>
		<tfoot>
			<tr>
				<th colspan="3"></th>
			</tr>
		</tfoot>
	</table></li>
	<li><script type='text/javascript' subtype='test'>
$assert.scope(function($assert,log){
//假设有个对象，需要经历 load,init,enable之后才是可以使用的对象
var script = new yi.Whenable();
//为了模拟这3个操作是异步，我们把mockContext传入这3个操作，然后按倒顺调用。
var mockContext = {};
//这个数组记录调用顺序
var invokes = [];
var completes = [];
//定义这3个模拟的操作
script.load =function(arg,dfd){
	var dfd = dfd || new yi.Whenable();
	log("loading");
	setTimeout(function(){
		invokes.push("load");
		completes.push("load");
		log("loaded");
		dfd.resolve("loaded");
	},50);
	return dfd;
}
script.init = function(arg,dfd){
	dfd || (dfd = new yi.Whenable());
	$assert(initData,arg);
	$assert(dfd, this);
	setTimeout(function(){
		invokes.push("init");
		completes.push("init");
		log("inited");
		dfd.resolve("inited");
	},60);
	log("initializing");
	return dfd;
}
script.enable = function(args,dfd){
	dfd || (dfd = new yi.Whenable());
	$assert(args,enableData);
	setTimeout(function(){
		invokes.push("enable");
		completes.push("enable");
		log("enabled");
		dfd.resolve("enabled");
	},70);
	log("enabling");
	return dfd;
}
var initData={};
var enableData ={};
script.load()
//如果init是this无关的，就可以使用这种方式
.thenWhen(script.init,initData)
.thenWhen(function(arg,dfd){script.enable(arg,dfd);},enableData).done(function(){
	log("object script is enabled.");
});

});
	</script></li>
	</ul>
 </fieldset>
 </body>
</html>
